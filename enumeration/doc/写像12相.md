# 写像12相

$k$ 個の箱に $n$ 個の玉を入れる場合の数。

| 箱と玉 | 1個以内 | 制限なし | 1個以上 |
| -- | ------ | ------ | ------ |
| どちらも区別する | [$_k \text{P}_n$](#permutation) | $k^n$ | [$k! S(n, k)$](#stirling2) |
| 玉は区別しない | [$_k \text{C}_n$](#binomial) | [$_k \text{H}_n$](#homo) | [$_{n - 1} \text{C}_{k - 1}$](#binomial) |
| 箱は区別しない | $0, 1$ | [$B(n, k)$](#bell) | [$S(n, k)$](#stirling2) |
| どちらも区別しない | $0, 1$ | [$P(n, k)$](#partition) | [$P(n - k, k)$](#partition) |

ただし、

- $_k \text{P}_n$ は[順列](#permutation)
- $_k \text{C}_n$ は[二項係数（組合せ）](#binomial)
- $_k \text{H}_n = _{n + k - 1} \text{C}_{n}$ は[重複組合せ](#homo)
- $S(n, k)$ は[第二種スターリング数](#stirling2)
- $B(n, k)$ は[ベル数](#bell)
- $P(n, k)$ は[分割数](#partition)

<h2 id="struct-combination"><code>EnumerationMod, Enumeration</code> 構造体の使い方</h2>

種々の計算 $\text{mod } p$ を前計算するための構造体。

`EnumerationMod` は普通の整数で出力、 `Enumeration` は `ModInt` で出力する。

`ModInt` を使わない場合は `EnumerationMod` 構造体を使う。

```Rust
let p = 1000000007i64;

// 初期化
let en = EnumerationMod::new(p);
```

`ModInt` を使う場合は `Enumeration` 構造体を使う。

```Rust
type Mint = ModInt1000000007;

// 初期化
let en = Enumeration::<Mint>::new();
```

<h2 id="permutation">順列の計算</h2>

$_n \text{P}_r$

### クエリ $O(n)$

```Rust
use enumeration::permutation;

// クエリ
permutation(n, r)
```

### $\text{mod } p$ , 前処理 $O(n)$ , クエリ $O(1)$

[`EnumerationMod` または `Enumeration` 構造体](#struct-combination)を使う。

```Rust
// クエリ
en.perm(n, r)
```

<h2 id="binomial">二項係数の計算</h2>

$_n \text{C}_r$

### クエリ $O(r)$

```Rust
use enumeration::binomial;

// クエリ
binomial(n, r)
```

### 前処理 $O(n)$ , クエリ $O(1)$ もしくは前処理 $O(r)$ , クエリ $O(r)$

[`EnumerationMod` または `Enumeration` 構造体](#struct-combination)を使う。

$n$ の大きさによって処理の方法が自動的に切り替わる。

```Rust
// クエリ
en.binom(n, r)
```

<h2 id="binomial">重複組合せの計算</h2>

$_n \text{H}_r$

### クエリ $O(r)$

```Rust
use enumeration::combination_with_repetition;

// クエリ
combination_with_repetition(n, r)
```

### 前処理 $O(n)$ , クエリ $O(1)$ もしくは前処理 $O(r)$ , クエリ $O(r)$

[`EnumerationMod` または `Enumeration` 構造体](#struct-combination)を使う。

$n$ の大きさによって処理の方法が自動的に切り替わる。

```Rust
// クエリ
en.homo(n, r)
```

<h2 id="partition">分割数の計算</h2>

$P(n, k)$

### 前処理 $O(nk)$ , クエリ $O(1)$

[`EnumerationMod` または `Enumeration` 構造体](#struct-combination)を使う。

```Rust
// クエリ
en.partition(n, k)
```

<h2 id="stirling2">第二種スターリング数の計算</h2>

$S(n, k)$

### 前処理 $O(k)$ , クエリ $O(k log n)$

[`EnumerationMod` または `Enumeration` 構造体](#struct-combination)を使う。

```Rust
// クエリ
en.stirling2(n, k)
```

<h2 id="bell">ベル数の計算</h2>

$B(n, k)$

### 前処理 $O(k)$ , クエリ $O(min(n, k) log n)$

[`EnumerationMod` または `Enumeration` 構造体](#struct-combination)を使う。

```Rust
// クエリ
en.bell(n, k)
```