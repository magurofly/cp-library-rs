# [グラフライブラリ](https://github.com/magurofly/cp-library-rs/blob/main/graphs.rs)

## 依存性

* `itertools`
* `num_traits`
* `rustc_hash`

## ドキュメント

### グラフを作る

```rust
use graphs::*;
// E: 辺の重み
// n: 頂点数
let graph = VecGraph::<E>::new(n);
```

### 探索する

```rust
graph.dfs(start, |edge| { ... });
graph.bfs(start, |edge| { ... });
graph.eulertour(start, |edge| { ... });

graph.walk(start, |walker, u| {
  walker.go_next(v); // すぐ行く (DFS)
  walker.forget(v); // 訪問済みフラグを消す
  walker.go_later(v); // 後で行く (BFS)
});
```

### 最短路

```rust
let dist = graph.shortest_path_bfs(start);
let dist = graph.shortest_path_dijkstra(start);
let dist = graph.shortest_path_spfa(start);

let dist = graph.shortest_path_bfs_by::<usize>(start, |edge, d| Some(d + 1) );
let dist = graph.shortest_path_dijkstra_by(start, |edge, d| Some(d + *edge.weight()) );
let dist = graph.shortest_path_spfa_by(start, |edge, d| Some(d + *edge.weight()) );
```

### 最小全域木

```rust
let (cost, subgraph) = graph.minimum_spanning_tree_prim(root);
```

## TODO

* 頂点の ID を `usize` ではなく `impl Clone + Eq + Hash` にする（デフォルトでは `usize` を使いたいが、頂点倍加もしたい） 
* 最短路アルゴリズムを充実させる
