# 最小費用流

Primal-Dual 法（負辺対応）

流量が大きいと遅いので注意

```rs
pub use mincostflow::*;
pub mod mincostflow {
  /// 最小費用流を Primal-Dual 法により求める
  pub struct MinCostFlow {
    graph: Vec<Vec<usize>>,
    arcs: Vec<Arc>,
  }
  impl MinCostFlow {
    pub fn new() -> Self {
      Self {
        graph: vec![],
        arcs: vec![],
      }
    }

    pub fn add_vertex(&mut self) -> usize {
      let v = self.graph.len();
      self.graph.push(vec![]);
      v
    }

    pub fn add_vertices(&mut self, add: usize) -> Vec<usize> {
      self.graph.reserve(add);
      (0 .. add).map(|_| self.add_vertex() ).collect::<Vec<_>>()
    }

    pub fn add_arc(&mut self, from: usize, to: usize, cap: i64, cost: i64) -> usize {
      assert!(from < self.graph.len());
      assert!(to < self.graph.len());
      assert!(cap >= 0);
      let e = self.arcs.len();
      self.arcs.push(Arc { to, rev: e + 1, cap, flow: 0, cost });
      self.arcs.push(Arc { to: from, rev: e, cap, flow: cap, cost: -cost });
      self.graph[from].push(e);
      self.graph[to].push(e + 1);
      e
    }

    pub fn arc(&self, e: usize) -> &Arc {
      assert!(e < self.arcs.len());
      &self.arcs[e]
    }

    pub fn min_cost_max_flow(&mut self, source: usize, sink: usize) -> (i64, i64) {
      let limit = self.graph[source].iter().map(|&e| self.arcs[e].residual_cap() ).sum::<i64>();
      self.min_cost_flow(source, sink, limit)
    }

    pub fn min_cost_flow(&mut self, source: usize, sink: usize, limit: i64) -> (i64, i64) {
      let mut unit = 1;//self.arcs.iter().map(|arc| arc.residual_cap() as u64 ).max().unwrap().next_power_of_two() as i64;
      let mut flow_sum = 0;
      let mut cost_sum = 0;
      while unit > 0 {
        'iteration: while limit - flow_sum >= unit {
          // dual
          let mut potential = vec![0i64; self.graph.len()];
          let mut queue = (0 .. self.graph.len()).collect::<VecDeque<_>>();
          let mut in_queue = vec![true; self.graph.len()];
          let mut count = vec![0; self.graph.len()];
          while let Some(u) = queue.pop_front() {
            in_queue[u] = false;
            for &e in &self.graph[u] {
              let arc = self.arcs[e];
              let v = arc.to;
              let d2 = potential[u].saturating_add(arc.cost);
              if self.arcs[e].residual_cap() >= unit && potential[v] > d2 {
                potential[v] = d2;
                if !in_queue[v] {
                  in_queue[v] = true;
                  queue.push_back(v);
                  count[v] += 1;
                  // if count[v] == self.graph.len() {
                  //   potential[v] = std::i64::MIN;
                  // }
                }
              }
            }
          }
          let mut dist = vec![std::i64::MAX; self.graph.len()];
          let mut prev = vec![self.arcs.len(); self.graph.len()];
          dist[source] = 0;
          let mut pq = BinaryHeap::new();
          pq.push((Reverse(0), source));
          while let Some((Reverse(d), u)) = pq.pop() {
            if dist[u] < d {
              continue;
            }
            for &e in &self.graph[u] {
              let arc = self.arcs[e];
              let v = arc.to;
              let d2 = dist[u] + arc.cost - (potential[v] - potential[u]);
              if dist[v] > d2 && arc.residual_cap() >= unit {
                dist[v] = d2;
                prev[v] = e;
                pq.push((Reverse(d2), v));
              }
            }
          }
          if dist[sink] == std::i64::MAX {
            break 'iteration;
          }
          for v in 0 .. self.graph.len() {
            potential[v] = potential[v].saturating_sub(dist[sink].saturating_sub(dist[v]));
          }

          // primal
          let mut delta = limit - flow_sum;
          let mut path = vec![];
          let mut v = sink;
          while v != source {
            let e = prev[v];
            let re = self.arcs[e].rev;
            path.push((e, re));
            delta = delta.min(self.arcs[e].residual_cap());
            v = self.arcs[re].to;
          }
          flow_sum += delta;
          cost_sum += (potential[sink] - potential[source]) * delta;
          for &(e, re) in &path {
            self.arcs[e].flow += delta;
            self.arcs[re].flow -= delta;
          }
        }

        unit /= 2;
      }
      (flow_sum, cost_sum)
    }
  }

  #[derive(Clone, Copy, Debug)]
  pub struct Arc {
    pub to: usize,
    pub rev: usize,
    pub cap: i64,
    pub flow: i64,
    pub cost: i64,
  }
  impl Arc {
    pub fn residual_cap(&self) -> i64 {
      self.cap - self.flow
    }
  }

  use std::cmp::*;
  use std::collections::*;
}
```
