# ダイクストラ法

```rust
fn dijkstra<E, C: Copy + num_traits::Num + Eq + Ord>(graph: &Vec<Vec<(usize, E)>>, start: usize, mut cost: impl FnMut(&(usize, E), C) -> Option<C>) -> Vec<Option<C>> {
  let mut dists = vec![None; graph.len()];
  dists[start] = Some(C::zero());
  let mut pq = std::collections::BinaryHeap::new();
  pq.push((std::cmp::Reverse(C::zero()), start));
  while let Some((std::cmp::Reverse(d1), u)) = pq.pop() {
    if dists[u].unwrap() != d1 { continue }
    for e in &graph[u] {
      if let Some(d2) = (cost)(e, d1) {
        if dists[e.0].map(|d3| d3 > d2 ).unwrap_or(true) {
          dists[e.0] = Some(d2);
          pq.push((std::cmp::Reverse(d2), e.0));
        }
      }
    }
  }
  dists
}
```

## 使用法（基本）

`隣接リスト`、`始点`、`コスト計算関数`を渡すと、`Option<距離>`の配列を返す。

`コスト計算関数`は`辺`と`現在の距離`を受け取り、`Option<次の距離>`を返すことを想定されている。（`None`の場合はその辺は通らない）

```rust
let dists = dijkstra(&graph, start, |&(_to, cost), dist| Some(dist + cost) );
println!("{}", dists[goal].unwrap_or(-1));
```

## 到着時刻をKの倍数に制限する

```rust
let dists = dijkstra(&graph, start, |&(_to, cost), dist| Some((dist + cost + K - 1) / K * K) );
println!("{}", dists[goal].unwrap_or(-1));
```

- [技術室奥プログラミングコンテスト#4 Day1 H - don't be late](https://atcoder.jp/contests/tkppc4-1/submissions/23281297)

## コスト関数として特殊な関数を使う

- [ABC204 E - Rush Hour 2](https://atcoder.jp/contests/abc204/submissions/23281757)
