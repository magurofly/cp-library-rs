順列や組合せの差分更新を取れるやつ

# 順列・組合せ
```rs
/// `slice` の中身を辞書順で一つ次になるよう並び替える。
/// 並び替えは要素の swap によって行い、その際 `swap_hook(slice, i, j)` が呼び出される。
/// 最悪計算量: $O(n)$ 、償却計算量: $O(1)$
fn next_permutation<T: Ord>(slice: &mut [T], mut swap_hook: impl FnMut(&[T], usize, usize)) -> bool {
  if slice.len() < 2 {
    return false;
  }

  let mut i = slice.len() - 1;
  while i > 0 && slice[i - 1] >= slice[i] {
    i -= 1;
  }

  if i == 0 {
    return false;
  }

  let mut j = slice.len() - 1;
  while j >= i && slice[j] <= slice[i - 1] {
    j -= 1;
  }

  swap_hook(&slice[..], i - 1, j);
  slice.swap(i - 1, j);

  for d in 0 .. (slice.len() - i) / 2 {
    let l = i + d;
    let r = slice.len() - 1 - d;
    if slice[l] != slice[r] {
      swap_hook(&slice[..], l, r);
      slice.swap(l, r);
    }
  }

  true
}

/// `slice` の中身を辞書順で一つ前になるよう並び替える。
/// 並び替えは要素の swap によって行い、その際 `swap_hook(slice, i, j)` が呼び出される。
/// 最悪計算量: $O(n)$ 、償却計算量: $O(1)$
fn prev_permutation<T: Ord>(slice: &mut [T], mut swap_hook: impl FnMut(&[T], usize, usize)) -> bool {
  if slice.len() < 2 {
    return false;
  }

  let mut i = slice.len() - 1;
  while i > 0 && slice[i - 1] <= slice[i] {
    i -= 1;
  }

  if i == 0 {
    return false;
  }

  for d in 0 .. (slice.len() - i) / 2 {
    let l = i + d;
    let r = slice.len() - 1 - d;
    if slice[l] != slice[r] {
      swap_hook(&slice[..], l, r);
      slice.swap(l, r);
    }
  }

  let mut j = slice.len() - 1;
  while j >= i && slice[j - 1] < slice[i - 1] {
    j -= 1;
  }

  swap_hook(&slice[..], i - 1, j);
  slice.swap(i - 1, j);

  true
}


/// `set` によって表される集合を、要素数が同じまま、選んだ要素を昇順に並べたときの辞書順が一つ次になるよう選ぶ要素を変える。
/// 集合の変更は要素の toggle によって行い、その際 `toggle_hook(index, insert_or_remove)` が呼び出される。
/// - `insert_or_remove`: 挿入の場合 `true` 、削除の場合 `false`
/// 最悪計算量: $O(n)$ 、償却計算量: $O(1)$
fn next_combination(set: &mut [bool], mut toggle_hook: impl FnMut(usize, bool)) -> bool {
    prev_permutation(set, |set, i, j| {
        toggle_hook(i, set[j]);
        toggle_hook(j, set[i]);
    })
}

/// `set` によって表される集合を、要素数が同じまま、選んだ要素を昇順に並べたときの辞書順が一つ前になるよう選ぶ要素を変える。
/// 並び替えは要素の toggle によって行い、その際 `toggle_hook(index, insert_or_remove)` が呼び出される。
/// - `insert_or_remove`: 挿入の場合 `true` 、削除の場合 `false`
/// 最悪計算量: $O(n)$ 、償却計算量: $O(1)$
fn prev_combination(set: &mut [bool], mut toggle_hook: impl FnMut(usize, bool)) -> bool {
    next_permutation(set, |set, i, j| {
        toggle_hook(i, set[j]);
        toggle_hook(j, set[i]);
    })
}

```

# 重複組合せ
```rs
/// `set` によって表される多重集合を、要素数が同じまま、選んだ要素を昇順に並べたときの辞書順が一つ次になるよう選ぶ要素を変える。
/// 
/// 多重集合は、玉を `true` 、仕切りを `false` とする「仕切りと玉」表現で与えられる。（なお、仕切りの個数は `kinds - 1` 個でなければならない。）
/// 仕切りによって区切られた連続する玉のうち、 $i$ 番目の玉の個数を、 $i$ 種類目の要素の個数とする。
/// 例: `vec![true, false, false, true, true]` は ${0, 2, 2}$ を意味する。
/// 
/// 多重集合の変更は要素の toggle によって行い、その際 `toggle_hook(index, insert_or_remove)` が呼び出される。
/// - `insert_or_remove`: 挿入の場合 `true` 、削除の場合 `false`
/// 最悪計算量: $O(n)$ 、償却計算量: $O(1)$
fn next_combination_with_repetition(multiset: &mut [bool], kinds: usize, mut toggle_hook: impl FnMut(usize, bool)) -> bool {
  if multiset.len() < 2 || kinds < 2 {
    return false;
  }

  let mut i = multiset.len() - 1;
  let mut at_i = kinds - 1;
  while i > 0 && multiset[i - 1] <= multiset[i] {
    at_i -= !multiset[i] as usize;
    i -= 1;
  }
  at_i -= !multiset[i] as usize;

  if i == 0 {
    return false;
  }

  let mut at_r = kinds - 1;
  for r in (i .. multiset.len()).rev() {
    if multiset[r] {
      toggle_hook(at_r, false);
      toggle_hook(at_i, true);
    }
    at_r -= !multiset[r] as usize;
    if at_r == at_i {
      break;
    }
  }
  multiset[i ..].reverse();

  let mut j = multiset.len() - 1;
  let mut at_j = kinds - 1;
  while j >= i && multiset[j - 1] < multiset[i - 1] {
    at_j -= !multiset[j] as usize;
    j -= 1;
  }

  let mut at_k = at_i;
  for k in i .. j {
    toggle_hook(at_k, false);
    toggle_hook(at_k + 1, true);
    at_k += !multiset[k] as usize;
  }

  toggle_hook(at_i - !multiset[i - 1] as usize, multiset[j]);
  toggle_hook(at_j, multiset[i - 1]);
  multiset.swap(i - 1, j);

  true
}

/// `set` によって表される多重集合を、要素数が同じまま、選んだ要素を昇順に並べたときの辞書順が一つ前になるよう選ぶ要素を変える。
/// 
/// 多重集合は、玉を `true` 、仕切りを `false` とする「仕切りと玉」表現で与えられる。（なお、仕切りの個数は `kinds - 1` 個でなければならない。）
/// 仕切りによって区切られた連続する玉のうち、 $i$ 番目の玉の個数を、 $i$ 種類目の要素の個数とする。
/// 例: `vec![true, false, false, true, true]` は ${0, 2, 2}$ を意味する。
/// 
/// 多重集合の変更は要素の toggle によって行い、その際 `toggle_hook(index, insert_or_remove)` が呼び出される。
/// - `insert_or_remove`: 挿入の場合 `true` 、削除の場合 `false`
/// 最悪計算量: $O(n)$ 、償却計算量: $O(1)$
fn prev_combination_with_repetition(multiset: &mut [bool], kinds: usize, mut toggle_hook: impl FnMut(usize, bool)) -> bool {
  if multiset.len() < 2 || kinds < 2 {
    return false;
  }

  let mut i = multiset.len() - 1;
  let mut at_i = kinds - 1;
  while i > 0 && multiset[i - 1] >= multiset[i] {
    at_i -= !multiset[i] as usize;
    i -= 1;
  }
  at_i -= !multiset[i] as usize;

  if i == 0 {
    return false;
  }

  let mut j = multiset.len() - 1;
  let mut at_j = kinds - 1;
  while j >= i && multiset[j] <= multiset[i - 1] {
    at_j -= !multiset[j] as usize;
    j -= 1;
  }

  let mut at_k = at_i;
  for k in i .. j {
    toggle_hook(at_k, false);
    toggle_hook(at_k - 1, true);
    at_k += !multiset[k] as usize;
  }

  toggle_hook(at_i - !multiset[i - 1] as usize, multiset[j]);
  toggle_hook(at_j, multiset[i - 1]);
  multiset.swap(i - 1, j);

  let mut at_r = kinds - 1;
  for r in (i .. multiset.len()).rev() {
    if multiset[r] && at_r != kinds {
      toggle_hook(at_r, false);
      toggle_hook(kinds - 1, true);
    }
    at_r -= !multiset[r] as usize;
  }
  multiset[i ..].reverse();

  true
}

```
