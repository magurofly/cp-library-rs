# ナップサック

## 01-最小個数部分和

価値が決まったいくつかの品物について、ある価値になる選び方のうち、個数が最小になるもの。

* 計算量: 時間 O(|A|ΣA), 空間 O(ΣA)
* 引数:
  * `A`: 非負整数の集合
* 返り値: 

```rust
fn subset_sum_min_count(items: &Vec<usize>) -> Vec<Option<usize>> {
  let all_sum = items.iter().sum::<usize>();
  let mut dp = vec![None; all_sum + 1];
  dp[0] = Some(0);
  for &value in items {
    for sum in (value ..= all_sum).rev() {
      if let Some(count1) = dp[sum - value] {
        if dp[sum].map(|count2| count2 > count1 + 1 ).unwrap_or(true) {
          dp[sum] = Some(count1 + 1);
        }
      }
    }
  }
  dp
}
```

## 01-ナップサック（価値最大化）

重さと価値が決まったいくつかの品物について、ある重さになる選び方のうち、価値が最大になるもの。

* 引数:
  * `A`: 非負整数のペア `(重さ, 価値)` の集合

```rust
fn subset_sum_max_value<N>(items: &Vec<(usize, N)>) -> Vec<Option<N>> where N: Clone + std::ops::Add<Output = N> + Ord + Default {
  let all_sum = items.iter().map(|a| a.0 ).sum::<usize>();
  let mut dp = vec![None; all_sum + 1];
  dp[0] = Some(N::default());
  for (weight, value1_1) in items {
    for weight_sum in (*weight ..= all_sum).rev() {
      if let Some(value1_2) = &dp[weight_sum - weight] {
        let value1 = value1_1.clone() + value1_2.clone();
        if dp[weight_sum].as_ref().map(|value2| value2 < &value1 ).unwrap_or(true) {
          dp[weight_sum] = Some(value1);
        }
      }
    }
  }
  dp
}
```
