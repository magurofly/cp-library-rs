# ナップサック

## 01-最小個数部分和

価値が決まったいくつかの品物について、ある価値になる選び方のうち、個数が最小になるもの。

* 計算量:
  * 時間: `O(個数 * 価値の総和)`
  * 空間: `O(価値の総和)`
* 引数:
  * `items`: 非負整数の集合
* 返り値: `[価値] = 最小の個数`

```rust
fn subset_sum_min_count(items: &Vec<usize>) -> Vec<Option<usize>> {
  let all_sum = items.iter().sum::<usize>();
  let mut dp = vec![None; all_sum + 1];
  dp[0] = Some(0);
  for &value in items {
    for sum in (value ..= all_sum).rev() {
      if let Some(count1) = dp[sum - value] {
        if dp[sum].map(|count2| count2 > count1 + 1 ).unwrap_or(true) {
          dp[sum] = Some(count1 + 1);
        }
      }
    }
  }
  dp
}
```

## 01-ナップサック（価値最大化）

重さと価値が決まったいくつかの品物について、ある重さになる選び方のうち、価値が最大になるもの。

* 計算量:
  * 時間 O(個数 * 重さの総和)
  * 空間 O(重さの総和)
* 引数:
  * `items`: 非負整数のペア `(重さ, 価値)` の集合
* 返り値: `[重さ] = 最大の価値`

```rust
fn subset_sum_max_value<V>(items: &Vec<(usize, V)>) -> Vec<Option<V>> where V: Clone + std::ops::Add<Output = V> + Ord + Default {
  let all_sum = items.iter().map(|a| a.0 ).sum::<usize>();
  let mut dp = vec![None; all_sum + 1];
  dp[0] = Some(V::default());
  for (weight, value1_1) in items {
    for weight_sum in (*weight ..= all_sum).rev() {
      if let Some(value1_2) = &dp[weight_sum - weight] {
        let value1 = value1_1.clone() + value1_2.clone();
        if dp[weight_sum].as_ref().map(|value2| value2 < &value1 ).unwrap_or(true) {
          dp[weight_sum] = Some(value1);
        }
      }
    }
  }
  dp
}
```

## 01-ナップサック（重さ最小化）

重さと価値が決まったいくつかの品物について、ある価値になる選び方のうち、重さが最小になるもの。

* 計算量:
  * 時間 O(個数 * 価値の総和)
  * 空間 O(価値の総和)
* 引数:
  * `items`: 非負整数のペア `(重さ, 価値)` の集合
* 返り値: `[価値] = 最小の重さ`

```rust
fn subset_sum_min_weight<W>(items: &Vec<(W, usize)>) -> Vec<Option<W>> where W: Clone + std::ops::Add<Output = W> + Ord + Default {
  let all_sum = items.iter().map(|a| a.1 ).sum::<usize>();
  let mut dp = vec![None; all_sum + 1];
  dp[0] = Some(W::default());
  for (weight1_1, value) in items {
    for value_sum in (*value ..= all_sum).rev() {
      if let Some(weight1_2) = &dp[value_sum - value] {
        let weight1 = weight1_1.clone() + weight1_2.clone();
        if dp[value_sum].as_ref().map(|weight2| weight2 < &weight1 ).unwrap_or(true) {
          dp[value_sum] = Some(weight1);
        }
      }
    }
  }
  dp
}
```
